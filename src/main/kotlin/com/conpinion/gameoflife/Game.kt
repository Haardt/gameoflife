/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.conpinion.gameoflife

import arrow.syntax.function.pipe
import mu.KLogging

data class Cell(val x: Int, val y: Int, private val alive: Boolean = false) {
    fun alive() = copy(alive = true)
    fun isAlive() = alive
    fun dead() = copy(alive = false)
}

class Game(aliveCells: List<Cell>) {

    companion object : KLogging() {
        const val worldSizeX = 5
        const val worldSizeY = 5
    }

    private var world = (0..worldSizeX * worldSizeY)
            .map { num ->
                Cell(num % worldSizeY, (num / worldSizeY))
            }.toList()

    init {
        for (cell in aliveCells) {
            setAlive(cell.x, cell.y)
        }
    }

    fun getInitWorld() = world

    private fun setAlive(x: Int, y: Int) {
        val pos = x + (y * worldSizeX)
        world = world.mapIndexed() { index, cell ->
            if (index == pos) {
                println("$index == $pos >> X: $x Y: $y== X")
                cell.alive()
            } else {
                cell
            }
        }
    }

    private fun getCell(x: Int, y: Int): Cell {
        if (x < 0 || x >= worldSizeX) {
            return Cell(x, y)
        }
        if (y < 0 || y >= worldSizeY) {
            return Cell(x, y)
        }
        return world[x + (y * worldSizeY)]
    }

    private fun numberOfCellNeighbours(cell: Cell): Pair<Int, Cell> {
        return with(cell) {
            val neighbourPositions = listOf(
                    x - 1 to y,
                    x + 1 to y,
                    x to y - 1,
                    x to y + 1,
                    x - 1 to y - 1,
                    x + 1 to y + 1,
                    x + 1 to y - 1,
                    x - 1 to y + 1
            )
            neighbourPositions.map { (x, y) -> getCell(x, y) }.filter(Cell::isAlive)
                    .count() to cell
        }
    }

    fun calcCells(world: List<Cell>): List<Cell> {
        return world.map { numberOfCellNeighbours(it) }
                .map { (neighours, cell) ->
                    when (neighours) {
                        in 0..2 -> cell.dead()
                        3 -> cell.alive()
                        else -> if (cell.isAlive()) cell.dead() else cell
                    }
                }
    }

    fun printCells(world: List<Cell>): List<Cell> {
        logger.info { "New generation: " }
        world.foldIndexed("") { index, acc, cell ->
            fun render() = if (cell.isAlive()) acc + "X" else acc + "0"

            if ((index + 1) % (worldSizeX + 0) == 0) {
                logger.info { "${render()}" }
                ""
            } else {
                render()
            }
        }
        return world
    }
}

fun main() {
    val game = Game(listOf(

//            Cell(0, 0, true),
//            Cell(1, 0, true),
//            Cell(0, 1, true),
//            Cell(1, 1, true),

            Cell(2, 2, true),
            Cell(2, 3, true),
            Cell(2, 4, true)
    ))
    game.apply {
        printCells(getInitWorld())

        (0..10).fold(getInitWorld()) { world, _ ->
            world pipe ::calcCells pipe ::printCells
        }
    }
}
